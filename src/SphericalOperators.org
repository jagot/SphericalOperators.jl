#+TITLE: Coupling Operators in Spherical Symmetry
#+AUTHOR: Stefanos Carlstr√∂m
#+EMAIL: stefanos.carlstrom@gmail.com

#+PROPERTY: header-args:julia :session *julia-spherical-symmetry* :eval no-export

* COMMENT Setup
  #+BEGIN_SRC julia
    using Pkg
    Pkg.activate(".")
    using Test
  #+END_SRC

  #+RESULTS:
  : nothing

* Introduction
  The interaction in both the length gauge and the velocity gauge
  has this common form:
  \begin{subequations}
  \begin{align}
  \op{V}_{\textrm{l}}(t) &= q\vec{E}(t)\cdot\vec{M}\{r,r\} = q\vec{E}(t)\cdot\vec{M}\{1,1\}r,\\
  \op{V}_{\textrm{v}}(t) &=
  -\im q\vec{A}(t)\cdot\vec{M}\{
  \partial_r - \ell r^{-1},
  \partial_r + (\ell+1) r^{-1}
  \}\\
  &=
  -\im q\vec{A}(t)\cdot\vec{M}\{-\ell,\ell+1\}r^{-1}
  -\im q\vec{A}(t)\cdot\vec{M}\{1,1\}\partial_r\nonumber\\
  &\defd
  \op{V}_{\textrm{v}}^{(1)}(t)+
  \op{V}_{\textrm{v}}^{(2)}(t),\nonumber
  \end{align}
  \end{subequations}
  \begin{equation}
  \begin{aligned}
  \label{eqn:dipole-angular-structure}
  \vec{M}\{\mathfrak{a},\mathfrak{b}\}
  &\defd
  \bmat{
  \zeta(\mathfrak{a},\mathfrak{b})&
  \xi(\mathfrak{a},\mathfrak{b})&
  \upsilon(\mathfrak{a},\mathfrak{b})
  }^\top\\
  \implies
  \vec{A}\cdot\vec{M}\{\mathfrak{a},\mathfrak{b}\}
  &\equiv
  A_z\zeta(\mathfrak{a},\mathfrak{b})+
  A_x\xi(\mathfrak{a},\mathfrak{b})+
  A_y\upsilon(\mathfrak{a},\mathfrak{b})
  \end{aligned}
  \end{equation}
  \begin{subequations}
  \begin{align}
  \zeta(\mathfrak{a},\mathfrak{b}) \defd&
  +c^{\ell}_{m}
  &&\mathfrak{a}
  &\ketbra{\ell+1,m}{\ell, m}&\\
  &+c^{\ell-1}_{m}
  &&\mathfrak{b}
  &\ketbra{\ell-1,m}{\ell, m}&\nonumber\\\nonumber\\
  2\xi(\mathfrak{a},\mathfrak{b}) \defd&
  +b^\ell_m
  &&\mathfrak{a}
  &\ketbra{\ell+1,m+1}{\ell, m}&\\
  &-b^{\ell-1}_{-m-1}
  &&\mathfrak{b}
  &\ketbra{\ell-1,m+1}{\ell, m}&\nonumber\\
  &
  -b^\ell_{-m}
  &&\mathfrak{a}
  &\ketbra{\ell+1,m-1}{\ell, m}&\nonumber\\
  &+b^{\ell-1}_{m-1}
  &&\mathfrak{b}
  &\ketbra{\ell-1,m-1}{\ell, m}&,\nonumber
  \end{align}
  \end{subequations}
  where the angular coupling coefficients are
  \begin{equation}
  c^{\ell}_{m}\defd
  \left[
  \frac{(\ell+m+1)(\ell-m+1)}{(2\ell+3)(2\ell+1)}
  \right]^{1/2},
  \qquad
  b^{\ell}_{m}\defd
  \left[
  \frac{(\ell+m+2)(\ell+m+1)}{(2\ell+3)(2\ell+1)}
  \right]^{1/2}.
  \end{equation}


  \(\upsilon\) corresponds to polarization along \(y\),
  i.e. longitudinal polarization, which we do not consider.
* Spherical Basis
  #+BEGIN_SRC julia
    using Printf
    import Base: size

    abstract type AbstractSphericalBasis end

    size(L::AbstractSphericalBasis,i::Integer) = size(L)[i]

    struct SphericalBasis2d <: AbstractSphericalBasis
        ‚Ñì‚Çò·µ¢‚Çô::Integer
        ‚Ñì‚Çò‚Çê‚Çì::Integer
        n·µ£::Integer
        m::Integer
        function SphericalBasis2d(‚Ñì‚Çò‚Çê‚Çì::Integer, n·µ£::Integer; m::Integer=0, ‚Ñì‚Çò·µ¢‚Çô::Integer=m)
            @assert ‚Ñì‚Çò·µ¢‚Çô ‚â• 0
            @assert ‚Ñì‚Çò‚Çê‚Çì ‚â• ‚Ñì‚Çò·µ¢‚Çô
            @assert abs(m) ‚â§ ‚Ñì‚Çò‚Çê‚Çì
            @assert n·µ£ > 0
            # If m is conserved, there is no way of reaching an ‚Ñì <
            # abs(m). We therefore truncate the basis.
            if ‚Ñì‚Çò·µ¢‚Çô < abs(m)
                ‚Ñì‚Çò·µ¢‚Çô = abs(m)
                @printf("Warning: ‚Ñì‚Çò·µ¢‚Çô = %i is not reachable when starting in m = %i, when m is conserved. Truncating.\n",
                        ‚Ñì‚Çò·µ¢‚Çô, m)
            end
            new(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, n·µ£, m)
        end
    end

    """
        nopws(L[, ‚Ñì=L.‚Ñì‚Çò‚Çê‚Çì])

    Returns how many partial waves ‚àà [L.‚Ñì‚Çò·µ¢‚Çô,‚Ñì] are present in L.
    """
    nopws(L::SphericalBasis2d, ‚Ñì::Integer=L.‚Ñì‚Çò‚Çê‚Çì) = ‚Ñì - L.‚Ñì‚Çò·µ¢‚Çô + 1

    struct SphericalBasis3d <: AbstractSphericalBasis
        ‚Ñì‚Çò·µ¢‚Çô::Integer
        ‚Ñì‚Çò‚Çê‚Çì::Integer
        m‚Çò‚Çê‚Çì::Integer
        n·µ£::Integer
        function SphericalBasis3d(‚Ñì‚Çò‚Çê‚Çì::Integer, n·µ£::Integer; ‚Ñì‚Çò·µ¢‚Çô::Integer=0, m‚Çò‚Çê‚Çì::Integer=‚Ñì‚Çò‚Çê‚Çì)
            @assert ‚Ñì‚Çò·µ¢‚Çô ‚â• 0
            @assert ‚Ñì‚Çò‚Çê‚Çì ‚â• ‚Ñì‚Çò·µ¢‚Çô
            @assert m‚Çò‚Çê‚Çì ‚àà 0:‚Ñì‚Çò‚Çê‚Çì
            @assert n·µ£ > 0
            new(‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, m‚Çò‚Çê‚Çì, n·µ£)
        end
    end

    function nopws(L::SphericalBasis3d, ‚Ñì::Integer=L.‚Ñì‚Çò‚Çê‚Çì)
        if ‚Ñì > L.m‚Çò‚Çê‚Çì
            nopws(L, L.m‚Çò‚Çê‚Çì) + (‚Ñì-L.m‚Çò‚Çê‚Çì)*(2L.m‚Çò‚Çê‚Çì+1)
        else
            (‚Ñì+1)^2 - L.‚Ñì‚Çò·µ¢‚Çô^2
        end
    end

    size(L::AbstractSphericalBasis) = (nopws(L,L.‚Ñì‚Çò‚Çê‚Çì),L.n·µ£)

    export AbstractSphericalBasis, SphericalBasis2d, SphericalBasis3d, nopws
  #+END_SRC

  #+RESULTS:
  : nothing
*** TEST Creating spherical bases
    #+BEGIN_SRC julia
      L2d = SphericalBasis2d(10,100)
      L2dtrunc = SphericalBasis2d(10,100,‚Ñì‚Çò·µ¢‚Çô=8,m=1)
      L2dtrunc2 = SphericalBasis2d(10,100,m=7)
      L3d = SphericalBasis3d(10,100)
      L3dtruncm = SphericalBasis3d(10,100,m‚Çò‚Çê‚Çì=4)

      @test size(L2d,1) == 11
      @test size(L3d,1) == 121
      @test size(L2d,2) == 100
      @test size(L3d,2) == 100
      @test size(L2dtrunc2,1) == 4
      @test size(L3dtruncm,1) == 25+54
      nothing
    #+END_SRC

    #+RESULTS:
    : nothing
**** TEST Assert sensible input
     #+BEGIN_SRC julia
       @test_throws AssertionError SphericalBasis2d(0, 10; ‚Ñì‚Çò·µ¢‚Çô=-3)
       @test_throws AssertionError SphericalBasis2d(-1, 10)
       @test_throws AssertionError SphericalBasis2d(1, 10; ‚Ñì‚Çò·µ¢‚Çô=2)
       @test_throws AssertionError SphericalBasis2d(1, 10; m=2)
       @test_throws AssertionError SphericalBasis2d(1, -10)

       @test_throws AssertionError SphericalBasis3d(0, 10; ‚Ñì‚Çò·µ¢‚Çô=-3)
       @test_throws AssertionError SphericalBasis3d(-1, 10)
       @test_throws AssertionError SphericalBasis3d(1, 10; ‚Ñì‚Çò·µ¢‚Çô=2)
       @test_throws AssertionError SphericalBasis3d(1, -10)
       @test_throws AssertionError SphericalBasis3d(3, 10; m‚Çò‚Çê‚Çì=-1)
       @test_throws AssertionError SphericalBasis3d(3, 10; m‚Çò‚Çê‚Çì=4)

       nothing
     #+END_SRC

     #+RESULTS:
     : nothing

** Iterators over channels
   #+BEGIN_SRC julia
     each‚Ñì(L::SB) where {SB<:AbstractSphericalBasis} = L.‚Ñì‚Çò·µ¢‚Çô:L.‚Ñì‚Çò‚Çê‚Çì
     enumerate‚Ñì(L::SB) where {SB<:AbstractSphericalBasis} = enumerate(each‚Ñì(L))

     # No check is made that ‚Ñì ‚àà 0:‚Ñì‚Çò‚Çê‚Çì, for performance reasons
     eachm(L::SphericalBasis2d, ‚Ñì::Integer) = L.m:L.m
     function eachm(L::SphericalBasis3d, ‚Ñì::Integer)
         m‚Çò‚Çê‚Çì = min(‚Ñì,L.m‚Çò‚Çê‚Çì)
         -m‚Çò‚Çê‚Çì:m‚Çò‚Çê‚Çì
     end
     enumeratem(L::SB, ‚Ñì::Integer) where {SB<:AbstractSphericalBasis} = enumerate(eachm(L, ‚Ñì))

     # Since this function does not return lazy iterators, it may very well
     # be slow and inefficient.
     function each‚Ñìm(L::SB) where {SB<:AbstractSphericalBasis}
         map(each‚Ñì(L)) do ‚Ñì
             map(eachm(L, ‚Ñì)) do m
                 ‚Ñì,m
             end
         end |> v -> reduce(vcat,v)
     end
     enumerate‚Ñìm(L::SB) where {SB<:AbstractSphericalBasis} = enumerate(each‚Ñìm(L))

     export each‚Ñì, enumerate‚Ñì,
         eachm, enumeratem,
         each‚Ñìm, enumerate‚Ñìm
   #+END_SRC

   #+RESULTS:
   : nothing
*** TEST Iterating over spherical bases
    #+BEGIN_SRC julia
      L2d = SphericalBasis2d(10,100)
      L2dtrunc = SphericalBasis2d(10,100,‚Ñì‚Çò·µ¢‚Çô=8,m=1)
      L2dtrunc2 = SphericalBasis2d(10,100,m=7)
      L3d = SphericalBasis3d(10,100)
      L3dtruncm = SphericalBasis3d(10,100,m‚Çò‚Çê‚Çì=4)

      for ‚Ñì ‚àà 0:4
          @test eachm(L3dtruncm, ‚Ñì) == -‚Ñì:‚Ñì
      end
      for ‚Ñì ‚àà 5:10
          @test eachm(L3dtruncm, ‚Ñì) == -4:4
      end

      @test last.(enumerate‚Ñì(L2d)) == 0:10
      @test last.(enumeratem(L2d, 3)) == 0:0
      @test last.(enumeratem(L3d, 3)) == -3:3
      @test last.(enumerate‚Ñì(L2dtrunc)) == 8:10
      @test last.(enumeratem(L2dtrunc, 3)) == 1:1

      eL2d = enumerate‚Ñìm(L2d)
      eL3d = enumerate‚Ñìm(L3d)

      @test last(collect(eL2d))[end] == (10,0)
      @test last(collect(eL3d))[end] == (10,10)

      @test first.(eL2d) == 1:11
      @test first.(eL3d) == 1:121

      nothing
    #+END_SRC

    #+RESULTS:
    : nothing

** Pretty printing
   #+BEGIN_SRC julia
     spectroscopic = "spdfghiklmnoqrtuv"
     spectroscopic_label(‚Ñì) =
         ‚Ñì + 1 ‚â§ length(spectroscopic) ? spectroscopic[‚Ñì+1] : "$(‚Ñì)"

     function Base.show(io::IO, L::SphericalBasis2d)
         ‚Ñì‚Çò·µ¢‚Çô = spectroscopic_label(L.‚Ñì‚Çò·µ¢‚Çô)
         ‚Ñì‚Çò‚Çê‚Çì = spectroscopic_label(L.‚Ñì‚Çò‚Çê‚Çì)
         n‚Ñì = L.‚Ñì‚Çò‚Çê‚Çì - L.‚Ñì‚Çò·µ¢‚Çô + 1

         print("SphericalBasis2d(‚Ñì ‚àà $(‚Ñì‚Çò·µ¢‚Çô):$(‚Ñì‚Çò‚Çê‚Çì) = $(n‚Ñì) channels")
         if L.m != 0
             print(", m = $(L.m)")
         end
         print(", n·µ£ = $(L.n·µ£))")
     end

     function Base.show(io::IO, L::SphericalBasis3d)
         ‚Ñì‚Çò·µ¢‚Çô = spectroscopic_label(L.‚Ñì‚Çò·µ¢‚Çô)
         ‚Ñì‚Çò‚Çê‚Çì = spectroscopic_label(L.‚Ñì‚Çò‚Çê‚Çì)
         n‚Ñì = L.‚Ñì‚Çò‚Çê‚Çì - L.‚Ñì‚Çò·µ¢‚Çô + 1

         print("SphericalBasis3d(‚Ñì ‚àà $(‚Ñì‚Çò·µ¢‚Çô):$(‚Ñì‚Çò‚Çê‚Çì) = $(n‚Ñì) channels")
         if L.m‚Çò‚Çê‚Çì < L.‚Ñì‚Çò‚Çê‚Çì
             print(", m‚Çò‚Çê‚Çì = $(L.m‚Çò‚Çê‚Çì)")
         end
         print(" = $(nopws(L)) partial waves")
         print(", n·µ£ = $(L.n·µ£))")
     end

     print_formatted(fmt, args...) = @eval @printf($fmt, $(args...))

     function visualize(L::SphericalBasis2d)
         ns = length(spectroscopic_label(L.‚Ñì‚Çò‚Çê‚Çì))
         for ‚Ñì ‚àà each‚Ñì(L)
             print_formatted("%$(ns)s .\n", spectroscopic_label(‚Ñì))
         end
     end

     function visualize(L::SphericalBasis3d)
         ns = length(spectroscopic_label(L.‚Ñì‚Çò‚Çê‚Çì))
         for ‚Ñì ‚àà each‚Ñì(L)
             print_formatted("%$(ns)s ", spectroscopic_label(‚Ñì))
             m‚Çò‚Çê‚Çì = min(‚Ñì,L.m‚Çò‚Çê‚Çì)
             for m ‚àà -L.m‚Çò‚Çê‚Çì:-m‚Çò‚Çê‚Çì-1
                 print(" ")
             end
             for m ‚àà -m‚Çò‚Çê‚Çì:m‚Çò‚Çê‚Çì
                 print(".")
             end
             println()
         end
     end

     export visualize
   #+END_SRC

   #+RESULTS:
   : nothing
*** EXAMPLE Visualization
    #+BEGIN_SRC julia :exports both :results output
      for L ‚àà [SphericalBasis2d(10,100),
               SphericalBasis2d(10,100,‚Ñì‚Çò·µ¢‚Çô=8,m=1),
               SphericalBasis2d(10,100,m=7),
               SphericalBasis3d(10,100),
               SphericalBasis3d(10,100,m‚Çò‚Çê‚Çì=4),
               SphericalBasis3d(10,100,‚Ñì‚Çò·µ¢‚Çô=2,m‚Çò‚Çê‚Çì=4)]
          println(L)
          visualize(L)
          println()
      end
    #+END_SRC

    #+RESULTS:
    #+begin_example
    SphericalBasis2d(‚Ñì ‚àà s:n = 11 channels, n·µ£ = 100)
    s .
    p .
    d .
    f .
    g .
    h .
    i .
    k .
    l .
    m .
    n .

    SphericalBasis2d(‚Ñì ‚àà l:n = 3 channels, m = 1, n·µ£ = 100)
    l .
    m .
    n .

    SphericalBasis2d(‚Ñì ‚àà k:n = 4 channels, m = 7, n·µ£ = 100)
    k .
    l .
    m .
    n .

    SphericalBasis2d(‚Ñì ‚àà s:n = 11 channels = 121 partial waves, n·µ£ = 100)
    s           .
    p          ...
    d         .....
    f        .......
    g       .........
    h      ...........
    i     .............
    k    ...............
    l   .................
    m  ...................
    n .....................

    SphericalBasis2d(‚Ñì ‚àà s:n = 11 channels, m‚Çò‚Çê‚Çì = 4 = 79 partial waves, n·µ£ = 100)
    s     .
    p    ...
    d   .....
    f  .......
    g .........
    h .........
    i .........
    k .........
    l .........
    m .........
    n .........

    SphericalBasis2d(‚Ñì ‚àà d:n = 9 channels, m‚Çò‚Çê‚Çì = 4 = 75 partial waves, n·µ£ = 100)
    d   .....
    f  .......
    g .........
    h .........
    i .........
    k .........
    l .........
    m .........
    n .........
    #+end_example

* Orderings
  #+BEGIN_SRC julia
    abstract type Ordering end
    struct LexicalOrdering <: Ordering end

    # Lexical ordering for the 2d case
    ord(L::SphericalBasis2d,::Type{LexicalOrdering},‚Ñì,r) = nopws(L,‚Ñì-1)*L.n·µ£ .+ r
    ord(L::SphericalBasis2d,::Type{LexicalOrdering},‚Ñì,m,r) = nopws(L,‚Ñì-1)*L.n·µ£ .+ r

    # Lexical ordering for the 3d case
    ord(L::SphericalBasis3d,::Type{LexicalOrdering},‚Ñì,m,r) = (nopws(L,‚Ñì-1) + min(‚Ñì,L.m‚Çò‚Çê‚Çì) + m)*L.n·µ£ .+ r
  #+END_SRC

  #+RESULTS:
  : ord (generic function with 2 methods)

** TEST Lexical ordering
   #+BEGIN_SRC julia
     import SphericalOperators: ord, LexicalOrdering

     L2d = SphericalBasis2d(10,100)
     @test ord(L2d, LexicalOrdering, 0, 3:5) == 3:5
     @test ord(L2d, LexicalOrdering, 5, 3:5) == 503:505

     L2dtrunc = SphericalBasis2d(10,100,‚Ñì‚Çò·µ¢‚Çô=8,m=1)
     @test ord(L2dtrunc, LexicalOrdering, 8, 3:5) == 3:5
     @test ord(L2dtrunc, LexicalOrdering, 9, 3:5) == 103:105

     L2dtrunc2 = SphericalBasis2d(10,100,m=7)
     @test ord(L2dtrunc2, LexicalOrdering, 8, 3:5) == 103:105
     @test ord(L2dtrunc2, LexicalOrdering, 9, 3:5) == 203:205

     L3d = SphericalBasis3d(10,100)
     for (‚Ñì,m) ‚àà each‚Ñìm(L3d)
         @test ord(L3d, LexicalOrdering, ‚Ñì, m, 3:5) == (‚Ñì^2 + ‚Ñì + m)*L3d.n·µ£ .+ (3:5)
     end

     L3dtruncm = SphericalBasis3d(10,100,m‚Çò‚Çê‚Çì=4)
     for ‚Ñì ‚àà 0:4
         for m ‚àà eachm(L3dtruncm, ‚Ñì)
             @test ord(L3dtruncm, LexicalOrdering, ‚Ñì, m, 3:5) == (‚Ñì^2 + ‚Ñì + m)*L3dtruncm.n·µ£ .+ (3:5)
         end
     end
     for ‚Ñì ‚àà 5:L3dtruncm.‚Ñì‚Çò‚Çê‚Çì
         for m ‚àà eachm(L3dtruncm, ‚Ñì)
             @test ord(L3dtruncm, LexicalOrdering, ‚Ñì, m, 3:5) == (5^2 + 9*(‚Ñì - 5) + 4 + m)*L3dtruncm.n·µ£ .+ (3:5)
         end
     end

     L3dtrunc‚Ñìm = SphericalBasis3d(10,100,‚Ñì‚Çò·µ¢‚Çô=3,m‚Çò‚Çê‚Çì=4)
     for ‚Ñì ‚àà 3:4
         for m ‚àà eachm(L3dtrunc‚Ñìm, ‚Ñì)
             @test ord(L3dtrunc‚Ñìm, LexicalOrdering, ‚Ñì, m, 3:5) == (‚Ñì^2 - 9 + ‚Ñì + m)*L3dtrunc‚Ñìm.n·µ£ .+ (3:5)
         end
     end
     for ‚Ñì ‚àà 5:L3dtrunc‚Ñìm.‚Ñì‚Çò‚Çê‚Çì
         for m ‚àà eachm(L3dtrunc‚Ñìm, ‚Ñì)
             @test ord(L3dtrunc‚Ñìm, LexicalOrdering, ‚Ñì, m, 3:5) == (5^2 + 9*(‚Ñì - 5) - 9 + 4 + m)*L3dtrunc‚Ñìm.n·µ£ .+ (3:5)
         end
     end
   #+END_SRC

   #+RESULTS:
   : nothing

* Spherical Tensors
** COMMENT General coupling coefficients
   #+BEGIN_SRC julia
     using WignerSymbols

     function C(k, ‚Ñì, ‚Ñì‚Ä≤, q=0, m=0, m‚Ä≤=0)
         s = (-1)^(2‚Ñì-m)
         N = ‚àö((2‚Ñì+1)*(2‚Ñì‚Ä≤+1))
         W = wigner3j(‚Ñì, k, ‚Ñì‚Ä≤,
                      -m, q, m‚Ä≤)
         Wr = wigner3j(‚Ñì, k, ‚Ñì‚Ä≤,
                       0, 0, 0)
         s*N*W*Wr
     end
   #+END_SRC

   #+RESULTS:
   : C (generic function with 4 methods)

** Coupling coefficients for dipole operators
   #+BEGIN_SRC julia
     c(‚Ñì,m) = ‚àö((‚Ñì+m+1)*(‚Ñì-m+1)/((2‚Ñì+3)*(2‚Ñì+1)))
     b(‚Ñì,m) = ‚àö((‚Ñì+m+2)*(‚Ñì+m+1)/((2‚Ñì+3)*(2‚Ñì+1)))
   #+END_SRC

   #+RESULTS:
   : b (generic function with 1 method)

* Dipole Operators
** Dipole Stencils
   #+BEGIN_SRC julia
     abstract type MultipoleStencil end

     struct DipoleStencil <: MultipoleStencil
         exprs::Vector{Pair{Tuple, Function}}
     end
   #+END_SRC

   #+RESULTS:
   : nothing

   #+BEGIN_SRC julia
     macro dipole_stencil(exprs, name)
         # Turn the DSL statements into Expr:s that can be eval:ed later in
         # the context of the materialize! arguments.
         ds = map(filter(e -> typeof(e) == Expr, exprs.args[2].args)) do e
             coords = eval(e.args[1])
             expr = e.args[2]
             coords => eval(Expr(:(->), :(‚Ñì, m, ùîû, ùîü), expr))
         end |> DipoleStencil
         quote
             $(esc(name)) = $ds
         end
     end
   #+END_SRC

   #+RESULTS:
   : @dipole_stencil (macro with 1 method)

*** \(\zeta\)
    #+BEGIN_SRC julia :results verbatim
      @dipole_stencil(Œ∂) do
          (+1,0) -> c(‚Ñì,m)*ùîû(‚Ñì)
          (-1,0) -> c(‚Ñì-1,m)*ùîü(‚Ñì)
      end
      nothing
    #+END_SRC

    #+RESULTS:
    : nothing

*** \(\xi\)
    #+BEGIN_SRC julia :results verbatim
      @dipole_stencil(Œæ) do
          (+1,+1) -> b(‚Ñì,m)*ùîû(‚Ñì)/2
          (-1,+1) -> -b(‚Ñì-1,-m-1)*ùîü(‚Ñì)/2
          (+1,-1) -> -b(‚Ñì,-m)*ùîû(‚Ñì)/2
          (-1,-1) -> b(‚Ñì-1,m-1)*ùîü(‚Ñì)/2
      end
      nothing
    #+END_SRC

    #+RESULTS:
    : nothing

**** \(\xi^+\)
     #+BEGIN_SRC julia :results verbatim
       @dipole_stencil(Œæ‚Å∫) do
           (+1,+1) -> b(‚Ñì,m)*ùîû(‚Ñì)/2
           (-1,-1) -> b(‚Ñì-1,m-1)*ùîü(‚Ñì)/2
       end
       nothing
     #+END_SRC

     #+RESULTS:
     : nothing

**** \(\xi^-\)
     #+BEGIN_SRC julia :results verbatim
       @dipole_stencil(Œæ‚Åª) do
           (-1,+1) -> -b(‚Ñì-1,-m-1)*ùîü(‚Ñì)/2
           (+1,-1) -> -b(‚Ñì,-m)*ùîû(‚Ñì)/2
       end
       nothing
     #+END_SRC

     #+RESULTS:
     : nothing

** Materialize stencils
   #+BEGIN_SRC julia
     function materialize!(op, stencil::DipoleStencil, L::SphericalBasis2d,
                           ùîû::Function, ùîü::Function,
                           ::Type{O} = LexicalOrdering) where {O<:Ordering}
         prod(size(op)) == prod(size(L))^2 || throw(DimensionMismatch("materialize!"))
         exprs = map(stencil.exprs) do (coords,expr)
             coords[2] != 0 && error("SphericalBasis2d cannot materialize operators that do not conserve m")
             coords => eval(expr)
         end
         op .= 0
         rsel = 1:L.n·µ£
         for ‚Ñì in each‚Ñì(L)
             for (coords,e) in exprs
                 ‚Ñì‚Ä≤ = ‚Ñì+coords[1]
                 ‚Ñì‚Ä≤ ‚àâ each‚Ñì(L) && continue
                 op[ord(L,O,‚Ñì,rsel),ord(L,O,‚Ñì‚Ä≤,rsel)] += e(‚Ñì,L.m,ùîû,ùîü)
             end
         end
         op
     end

     function materialize!(op, stencil::DipoleStencil, L::SphericalBasis3d,
                           ùîû::Function, ùîü::Function,
                           ::Type{O} = LexicalOrdering) where {O<:Ordering}
         prod(size(op)) == prod(size(L))^2 || throw(DimensionMismatch("materialize!"))
         exprs = map(stencil.exprs) do (coords,expr)
             coords => eval(expr)
         end
         op .= 0
         rsel = 1:L.n·µ£
         for ‚Ñì in each‚Ñì(L)
             for (coords,e) in exprs
                 ‚Ñì‚Ä≤ = ‚Ñì + coords[1]
                 ‚Ñì‚Ä≤ ‚àâ each‚Ñì(L) && continue
                 for m in eachm(L,‚Ñì)
                     m‚Ä≤ = m + coords[2]
                     m‚Ä≤ ‚àâ eachm(L, ‚Ñì‚Ä≤) && continue
                     op[ord(L,O,‚Ñì,m,rsel),ord(L,O,‚Ñì‚Ä≤,m‚Ä≤,rsel)] += e(‚Ñì,m,ùîû,ùîü)
                 end
             end
         end
         op
     end

     export materialize!
   #+END_SRC

   #+RESULTS:
   : nothing

*** TEST Materialization
    #+BEGIN_SRC julia
      using SparseArrays
      using LinearAlgebra

      ‚Ñì‚Çò‚Çê‚Çì = 5
      n·µ£ = 10

      L2d = SphericalBasis2d(‚Ñì‚Çò‚Çê‚Çì,n·µ£)
      L3d = SphericalBasis3d(‚Ñì‚Çò‚Çê‚Çì,n·µ£)
      L3dtruncm = SphericalBasis3d(‚Ñì‚Çò‚Çê‚Çì,n·µ£,m‚Çò‚Çê‚Çì=3)

      N2d = prod(size(L2d))
      N3d = prod(size(L3d))
      N3dtruncm = prod(size(L3dtruncm))

      z2d = spzeros(N2d,N2d);
      z3d = spzeros(N3d,N3d);
      x3d = spzeros(N3d,N3d);
      x‚Å∫3d = spzeros(N3d,N3d);
      x‚Åª3d = spzeros(N3d,N3d);
      z3dtruncm = spzeros(N3dtruncm,N3dtruncm);
      x3dtruncm = spzeros(N3dtruncm,N3dtruncm);

      r = ‚Ñì -> spdiagm(0 => ones(n·µ£))

      import SphericalOperators: Œ∂, Œ∂, Œæ, Œæ‚Å∫, Œæ‚Åª

      materialize!(z2d, Œ∂, L2d, r, r);
      materialize!(z3d, Œ∂, L3d, r, r);
      materialize!(x3d, Œæ, L3d, r, r);
      materialize!(x‚Å∫3d, Œæ‚Å∫, L3d, r, r);
      materialize!(x‚Åª3d, Œæ‚Åª, L3d, r, r);
      materialize!(z3dtruncm, Œ∂, L3dtruncm, r, r);
      materialize!(x3dtruncm, Œæ, L3dtruncm, r, r);

      @test_throws ErrorException materialize!(z2d, Œæ, L2d, r, r)
      @test_throws DimensionMismatch materialize!(z2d, Œ∂, L3d, r, r)

      tmp2d = spzeros(N2d,N2d);
      tmp3d = spzeros(N3d,N3d);

      ùîû = ‚Ñì -> (‚Ñì+1)*I
      ùîü = ‚Ñì -> -‚Ñì*I

      materialize!(tmp2d, Œ∂, L2d, ùîû, ùîü);
      @test ishermitian(-im*tmp2d)

      materialize!(tmp3d, Œ∂, L3d, ùîû, ùîü);
      @test ishermitian(-im*tmp3d)
      materialize!(tmp3d, Œæ, L3d, ùîû, ùîü);
      @test ishermitian(-im*tmp3d)
      materialize!(tmp3d, Œæ, L3d, ùîû, ùîü);
      @test ishermitian(-im*tmp3d)
      materialize!(tmp3d, Œæ, L3d, ùîû, ùîü);
      @test ishermitian(-im*tmp3d)

      nothing
    #+END_SRC

    #+RESULTS:
    : nothing

**** EXAMPLE Plot
     #+BEGIN_SRC julia
       using PyPlot
       figure("dip", figsize=(10,3))
       clf()
       subplot(231)
       spy(Array(z2d))
       margins(0,0)
       subplot(232)
       spy(Array(z3d))
       margins(0,0)
       subplot(234)
       spy(Array(x3d))
       margins(0,0)
       subplot(235)
       spy(Array(x‚Å∫3d))
       margins(0,0)
       subplot(236)
       spy(Array(x‚Åª3d))
       margins(0,0)
       tight_layout()

       figure("trunc")
       clf()
       subplot(121)
       spy(Array(z3dtruncm))
       margins(0,0)
       subplot(122)
       spy(Array(x3dtruncm))
       margins(0,0)
       tight_layout()
     #+END_SRC

     #+RESULTS:
     : nothing

** Invariant sets
   Given a spherical basis and a dipole stencil, generate all
   invariant sets, i.e. those that can be exponentiated separately
   without considering the other partial waves.

   It is assumed that the stencil describes a Hermitian operator,
   i.e. if pw couples to pw‚Ä≤, the symmetric coupling element is
   assumed to be the conjugated value.
   #+BEGIN_SRC julia
     const Coupling = Pair{Tuple{Tuple{Integer,Integer},Tuple{Integer,Integer}},Real}
     function invariant_sets(L::AbstractSphericalBasis,
                             stencil::DipoleStencil,
                             ùîû::Function, ùîü::Function)
         pws = each‚Ñìm(L)
         sets = Vector{Coupling}[]
         exprs = map(stencil.exprs) do (coords,expr)
             L isa SphericalBasis2d && coords[2] != 0 && error("SphericalBasis2d cannot materialize operators that do not conserve m")
             coords => eval(expr)
         end
         function traversepws(set, pw)
             ‚Ñì,m = pw
             for (coords,e) in exprs
                 ‚Ñì‚Ä≤ = ‚Ñì + coords[1]
                 m‚Ä≤ = m + coords[2]
                 pw‚Ä≤ = ‚Ñì‚Ä≤,m‚Ä≤
                 i = findfirst(isequal(pw‚Ä≤), pws)
                 if i != nothing
                     v = e(‚Ñì,m,ùîû,ùîü)
                     v == 0 && continue
                     push!(set, (pw,pw‚Ä≤) => v)
                     deleteat!(pws, i)
                     traversepws(set, pw‚Ä≤)
                 end
             end
         end
         while !isempty(pws)
             pw = first(pws)
             deleteat!(pws, 1)
             set = Coupling[]
             traversepws(set, pw)
             !isempty(set) && push!(sets, set)
         end
         sets
     end

     export invariant_sets
   #+END_SRC

*** TEST Invariant sets
    #+BEGIN_SRC julia
      function test_is_invariant(sets)
          pws = first.(first.(sets))
          for i in eachindex(pws)
              other_pws = vcat([[pws[j]...] for j in vcat(1:i-1,i+1:length(sets))]...)
              @test isempty([pws[i]...] ‚à© other_pws)
          end
      end

      function test_set_coverage(L::AbstractSphericalBasis, op::SphericalOperators.DipoleStencil, setss...)
          # Ensure that all partial waves in L coupled by op are present in
          # at least one of the invariant sets generated.
          coords = map(first, op.exprs)
          pws = filter(each‚Ñìm(L)) do ‚Ñìm
              ‚Ñì,m = ‚Ñìm
              map(coords) do co
                  ‚Ñì‚Ä≤ = ‚Ñì + co[1]
                  m‚Ä≤ = m + co[2]
                  ‚Ñì‚Ä≤ ‚àà each‚Ñì(L) && m‚Ä≤ ‚àà eachm(L,‚Ñì‚Ä≤) && return true
                  false
              end |> any
          end
          set_pws = []
          for sets in setss
              for set in sets
                  append!(set_pws, vcat([[pw...] for pw in first.(first.(sets))]...))
              end
          end
          @test sort(pws) == sort(unique(set_pws))
      end

      L2d = SphericalBasis2d(5,1)

      # If no splitting is made, there is only one invariant set containing
      # all partial waves.
      sets = invariant_sets(L2d, SphericalOperators.Œ∂, ‚Ñì -> 1, ‚Ñì -> 1)
      @test length(sets) == 1
      @test length(sets[1]) == size(L2d,1)-1

      setse = invariant_sets(L2d, SphericalOperators.Œ∂, ‚Ñì -> iseven(‚Ñì), ‚Ñì -> isodd(‚Ñì))
      setso = invariant_sets(L2d, SphericalOperators.Œ∂, ‚Ñì -> isodd(‚Ñì), ‚Ñì -> iseven(‚Ñì))
      @test length(setse) + length(setso) == size(L2d,1)-1
      test_set_coverage(L2d, SphericalOperators.Œ∂, setse, setso)

      for set in setse
          @test length(set) == 1
      end
      test_is_invariant(setse)
      for set in setso
          @test length(set) == 1
      end
      test_is_invariant(setso)

      @test_throws ErrorException invariant_sets(L2d, SphericalOperators.Œæ, ‚Ñì -> 1, ‚Ñì -> 1)
      @test_throws ErrorException invariant_sets(L2d, SphericalOperators.Œæ‚Å∫, ‚Ñì -> 1, ‚Ñì -> 1)
      @test_throws ErrorException invariant_sets(L2d, SphericalOperators.Œæ‚Åª, ‚Ñì -> 1, ‚Ñì -> 1)

      L3d = SphericalBasis3d(5,1)

      for op in [SphericalOperators.Œ∂, SphericalOperators.Œæ‚Å∫, SphericalOperators.Œæ‚Åª]
          setse = invariant_sets(L3d, op, ‚Ñì -> iseven(‚Ñì), ‚Ñì -> isodd(‚Ñì))
          setso = invariant_sets(L3d, op, ‚Ñì -> isodd(‚Ñì), ‚Ñì -> iseven(‚Ñì))
          # @test length(setse) + length(setso) == size(L3d,1)-1
          test_set_coverage(L3d, op, setse, setso)

          for set in setse
              @test length(set) == 1
          end
          test_is_invariant(setse)
          for set in setso
              @test length(set) == 1
          end
          test_is_invariant(setso)
      end
    #+END_SRC


* LaTeX config                                                     :noexport:
  #+LATEX_HEADER: \renewcommand{\vec}[1]{\mathbf{#1}}
  #+LATEX_HEADER: \renewcommand{\op}[1]{\mathcal{#1}}
  #+LATEX_HEADER: \renewcommand{\defd}{\overset{!}{=}}
